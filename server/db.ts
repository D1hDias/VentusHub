import dotenv from 'dotenv';
dotenv.config();

import * as schema from "../shared/schema.js";

// Verificar conectividade do banco primeiro
let db: any;
let pool: any = null;

const isDevelopment = process.env.NODE_ENV === 'development';

// Fun√ß√£o para tentar conectar com retry
const conectarComRetry = async (tentativas = 3): Promise<boolean> => {
  for (let i = 1; i <= tentativas; i++) {
    try {
      console.log(`üîß Tentando conectar com Neon PostgreSQL... (tentativa ${i}/${tentativas})`);
      
      if (!process.env.DATABASE_URL) {
        throw new Error("DATABASE_URL n√£o configurada");
      }

      const { Pool, neonConfig } = await import('@neondatabase/serverless');
      const { drizzle } = await import('drizzle-orm/neon-serverless');
      const ws = await import("ws");

      neonConfig.webSocketConstructor = ws.default;

      // Configura√ß√£o mais robusta para lidar com timeouts
      neonConfig.poolQueryViaFetch = true; // Usar fetch em vez de WebSocket quando poss√≠vel
      neonConfig.useSecureWebSocket = true;
      
      pool = new Pool({ 
        connectionString: process.env.DATABASE_URL,
        max: 3, // Reduzido ainda mais
        min: 0, // Permitir zero conex√µes ativas
        idleTimeoutMillis: 20000, // Reduzido
        connectionTimeoutMillis: 5000, // Reduzido
        query_timeout: 10000, // Timeout de query
        statement_timeout: 10000, // Timeout de statement
        // Configura√ß√µes de reconex√£o
        allowExitOnIdle: true,
      });

      // Teste de conectividade r√°pido
      const testClient = await Promise.race([
        pool.connect(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout na conex√£o')), 5000))
      ]);
      
      await testClient.query('SELECT NOW()');
      testClient.release();
      
      db = drizzle(pool, { schema });
      
      // Melhor tratamento de erros do pool
      pool.on('error', (err: any) => {
        if (isDevelopment) {
          console.warn('‚ö†Ô∏è Pool error (ser√° reconectado):', err.message);
        }
      });
      
      console.log("‚úÖ Banco Neon conectado com sucesso");
      return true;

    } catch (error) {
      console.log(`‚ùå Tentativa ${i} falhou: ${error.message}`);
      
      if (i < tentativas) {
        console.log(`‚è≥ Aguardando ${i * 2}s antes da pr√≥xima tentativa...`);
        await new Promise(resolve => setTimeout(resolve, i * 2000));
      }
    }
  }
  return false;
};

// Fun√ß√£o para inicializar a conex√£o (ser√° chamada pelo index.ts)
export const initializeDB = async () => {
  console.log("üîß Iniciando inicializa√ß√£o do banco...");
  console.log(`üîß Ambiente: ${isDevelopment ? 'development' : 'production'}`);
  console.log(`üîß DATABASE_URL definida: ${!!process.env.DATABASE_URL}`);
  
  try {
    // Adicionar timeout geral para inicializa√ß√£o
    const conectado = await Promise.race([
      conectarComRetry(2),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout na inicializa√ß√£o do banco (30s)')), 30000)
      )
    ]);
    
    if (!conectado) {
      throw new Error("N√£o foi poss√≠vel conectar ap√≥s v√°rias tentativas");
    }
    
    console.log("‚úÖ Inicializa√ß√£o do banco conclu√≠da com sucesso");
    return { db, pool };

  } catch (error) {
    console.log(`‚ùå Falha definitiva na conex√£o Neon: ${error.message}`);
    
    if (isDevelopment) {
      console.log("üîß Modo desenvolvimento: Usando banco fallback...");
      
      const { createFallbackDB } = await import('./db-fallback.js');
      db = createFallbackDB();
      
      console.log("‚úÖ Banco fallback criado para desenvolvimento");
      return { db, pool: null };
    } else {
      console.log("üí• Em produ√ß√£o - falhando se n√£o conseguir conectar ao banco");
      throw error; // Em produ√ß√£o, falhar se n√£o conseguir conectar
    }
  }
};

export { db, pool };